# Написать два алгоритма нахождения i-го по счёту простого числа.
# Функция нахождения простого числа должна принимать на вход
# натуральное и возвращать соответствующее простое число.
# Проанализировать скорость и сложность алгоритмов.

import cProfile


# Вариант 2
# _______________________________________________________________________

def fun_2(n):  # O(10*n) - итого ?????
    find_easy_num = 2
    m_easy_num_2 = [2]

    while len(m_easy_num_2) < n:  # O(n) - проход до n-го числа
        i = 0
        find_easy_num += 1
        while find_easy_num % m_easy_num_2[i] != 0:  # O(????) - проверка
            i += 1
            if i == len(m_easy_num_2):
                m_easy_num_2.append(find_easy_num)
                break

    return find_easy_num


def main(q):
    n1 = q
    fun_2(n1)


cProfile.run('main(2000)')

# 1    0.000    0.000    0.000    0.000 task_4_2_2.py:11(fun_2) q=50
# 1    0.001    0.001    0.002    0.002 task_4_2_2.py:11(fun_2) q=100
# 1    0.003    0.003    0.004    0.004 task_4_2_2.py:11(fun_2) q=150
# 1    0.005    0.005    0.007    0.007 task_4_2_2.py:11(fun_2) q=200
# 1    0.008    0.008    0.010    0.010 task_4_2_2.py:11(fun_2) q=250

# 1    0.131    0.131    0.173    0.173 task_4_2_2.py:11(fun_2) q=1000
# 1    0.537    0.537    0.701    0.701 task_4_2_2.py:11(fun_2) q=2000
